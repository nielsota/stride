import sqlmodel
import sqlalchemy
import os
from pathlib import Path
from loguru import logger
from sqlalchemy.orm import selectinload
from stride.stridedb.models import Activity
from stride.provider.strava.main import StravaService
from stride.stridedb.converters import StrideConverterService
from stride.enums import Provider

# Get the path to the data directory relative to this file
package_root = Path(__file__).parent.parent
data_dir = package_root / "data"
db_path = data_dir / "stridedb.db"

# Create data directory if it doesn't exist
os.makedirs(data_dir, exist_ok=True)


def get_sqlite_url(prod: bool = False) -> str:
    """Get the SQLite URL for the database."""
    prefix = "prod" if prod else "dev"
    db_file = data_dir / f"{prefix}_stridedb.db"
    return f"sqlite:///{db_file.absolute()}"


def get_engine(prod: bool = False) -> sqlalchemy.Engine:
    """Get the engine for the database."""
    return sqlmodel.create_engine(get_sqlite_url(prod))


def create_database(prod: bool = False) -> None:
    """Create database tables."""
    sqlmodel.SQLModel.metadata.create_all(get_engine(prod))


class StrideDBService:
    """Service for interacting with the stridedb."""

    def __init__(self, prod: bool = False):
        self.prod = prod
        self.engine = get_engine(prod)

    def save_activity(self, activity: Activity, update: bool = False, verbose: bool = True) -> Activity:
        """Save an activity and its streams to the database.

        1. check if activity exists
        2. if it does, but update is True, update it
        3. if it does, but update is False, print warning
        3. if it doesn't, save it

        Args:
            activity: Activity to save
            update: Whether to update the activity if it already exists
            verbose: Whether to print debug messages

        Returns:
            Saved activity with updated IDs
        """
        if self.check_if_activity_exists(activity.provider_activity_id, activity.provider):
            if update:
                return self.update_activity(activity, verbose=verbose)

            if verbose:
                logger.warning(f"Activity {activity.provider_activity_id}" " already exists in the database, skipping. (set update=True to update)")
            return activity

        return self.save_new_activity(activity, verbose=verbose)

    def save_new_activity(self, activity: Activity, verbose: bool = True) -> Activity:
        """Save a new activity to the database.

        Args:
            activity: Activity to save

        Returns:
            Saved activity with ID generated by the database
        """
        with sqlmodel.Session(self.engine) as session:
            logger.debug(f"Saving new activity from {activity.provider} with id {activity.provider_activity_id} in stridedb")
            session.add(activity)
            session.commit()
            session.refresh(activity)
            return activity

    def delete_activity(self, activity: Activity, verbose: bool = True) -> None:
        """Delete an activity from the database.

        Args:
            activity: Activity to delete
        """
        with sqlmodel.Session(self.engine) as session:
            statement = sqlmodel.select(Activity).where(Activity.id == activity.id)
            session.exec(statement).delete()
            session.commit()

    def update_activity(self, activity: Activity, verbose: bool = True) -> Activity:
        """Update an activity in the database.

        Args:
            activity: Activity to update

        Returns:
            Updated activity
        """
        if verbose:
            logger.debug(f"Updating activity {activity.id} in stridedb")
        self.delete_activity(activity=activity, verbose=False)  # false because we don't want to print dropping first
        self.save_new_activity(activity=activity, verbose=False)  # false because we don't want to print saving new
        return activity

    def check_if_activity_exists(self, provider_activity_id: int, provider: Provider) -> bool:
        """Check if an activity exists in the database.

        Args:
            provider_activity_id: ID of the activity
            provider: Provider of the activity

        Returns:
            True if the activity exists, False otherwise
        """
        with sqlmodel.Session(self.engine) as session:
            statement = sqlmodel.select(Activity).where(Activity.provider_activity_id == provider_activity_id, Activity.provider == provider)
            return session.exec(statement).first() is not None

    def get_activity(self, id: int) -> Activity:
        """Get an activity by ID.

        Args:
            activity_id: ID of the activity

        Returns:
            Activity from the database if found, raises an error otherwise
        """
        with sqlmodel.Session(self.engine) as session:
            statement = sqlmodel.select(Activity).options(selectinload(Activity.streams)).where(Activity.id == id)
            activity = session.exec(statement).first()

            if activity is None:
                raise ValueError(f"Activity {id} not found in the database")

            return activity

    def get_activities(self, limit: int = 100) -> list[Activity]:
        """Get activities from the database.

        Args:
            limit: Maximum number of activities to return

        Returns:
            List of activities
        """

        # open a session is like dialing the database
        with sqlmodel.Session(self.engine) as session:
            statement = sqlmodel.select(Activity).options(selectinload(Activity.streams)).limit(limit)
            return list(session.exec(statement))


if __name__ == "__main__":
    from rich import print as pprint

    prod = False
    create_database(prod)

    # get an activity from the strava
    strava_service = StravaService()
    strava_activity = strava_service.get_activity(15296669638)
    strava_streams = strava_service.get_streams(15296669638)

    # convert it to the stridedb format
    activity = StrideConverterService.process_strava_data(strava_activity, strava_streams)

    # save it
    StrideDBService(prod=prod).save_activity(activity)

    # test: save again
    StrideDBService(prod=prod).save_activity(activity)

    # print all activities
    activities = StrideDBService(prod=prod).get_activities()
    for activity in activities:
        pprint(activity)

    # get it from the database
    # activity = StrideDBService(prod=prod).get_activity(1)
    # pprint(activity)
